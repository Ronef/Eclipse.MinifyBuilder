/*
 * Eclipse Minify Builder
 * Copyright (C) 2017  Michael N. Lipp
 * 
 * This program is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU General Public License as published by 
 * the Free Software Foundation; either version 3 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along 
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 */

package org.jdrupes.eclipse.minify.plugin;

import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ProjectScope;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.osgi.service.prefs.BackingStoreException;
import org.osgi.service.prefs.Preferences;

/**
 * Started immediately with the workbench, this class registers a ResourceChangeListener
 * that adapts the project scoped properties of a file to moves (renames) and deletions. 
 * 
 * The mechanism provided here stores file related properties in a project
 * scoped preferences node. The key for accessing properties is generated by 
 * appending the property name, two slashes as separator and the project 
 * relative, os independent path (see {@link #preferenceKey(IResource, String)}).
 * This allows all properties of a file to be identified using 
 * {@link String#endsWith(String)}. This is similar to the scheme used by 
 * {@code org.eclipse.core.resources.prefs} for storing e.g. the encoding of a file
 * in project scoped preferences.
 * 
 * Such a class (started with the workbench) should -- according to the Eclipse
 * documentation -- never be written.
 */
public class PrefsAccess {

	/**
	 * Returns the plugin's project scoped preferences using the given 
	 * resource to identify the project.
	 * 
	 * @param resource a resource from the project
	 * @return the preferences
	 */
	public static Preferences preferences(IResource resource) {
		ProjectScope projectScope = new ProjectScope(resource.getProject());
		return projectScope.getNode(MinifyBuilder.BUILDER_ID);
	}
	
	/**
	 * Generate the key for a given resource and its associated property.
	 * 
	 * @param resource the resource
	 * @param property the property
	 * @return the key
	 */
	public static String preferenceKey(IResource resource, String property) {
		return property + "//" + resource.getProjectRelativePath().toPortableString();
	}

	/**
	 * Remove a resource (i.e. all its properties) from the builder's preferences.
	 * 
	 * @param prefs the preferences
	 * @param resource the resource
	 * @throws BackingStoreException
	 */
	public static void removeResource(Preferences prefs, IResource resource) 
			throws CoreException {
		try {
			String[] keys = prefs.keys();
			for (String key: keys) {
				if (key.endsWith("//" + resource.getProjectRelativePath().toPortableString())) {
					prefs.remove(key);
				}
			}
			prefs.flush();
		} catch (BackingStoreException e) {
			throw new CoreException(new Status(
					IStatus.ERROR, MinifyBuilder.BUILDER_ID, e.getMessage(), e));
		}
	}

	/**
	 * Associate one resource's properties with another resource.
	 * 
	 * @param fromPrefs the preferences to take the properties from
	 * @param fromResource the resource to take the properties from
	 * @param toPrefs the preferences to move the properties to
	 * @param toResource the resource to associated with the properties
	 * @throws BackingStoreException
	 */
	public static void moveResource(Preferences fromPrefs, IResource fromResource,
			Preferences toPrefs, IResource toResource) 
			throws CoreException {
		try {
			String[] keys = fromPrefs.keys();
			for (String key: keys) {
				if (key.endsWith("//" + fromResource.getProjectRelativePath().toPortableString())) {
					String resourcePreference = key.substring(0, key.indexOf('/'));
					toPrefs.put(preferenceKey(toResource, resourcePreference), fromPrefs.get(key, ""));
					fromPrefs.remove(key);
				}
			}
			fromPrefs.flush();
			toPrefs.flush();
		} catch (BackingStoreException e) {
			throw new CoreException(new Status(
					IStatus.ERROR, MinifyBuilder.BUILDER_ID, e.getMessage(), e));
		}
	}

}
